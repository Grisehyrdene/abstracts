# Получение объектов в JavaScript.

## Более старые методы.

    const name = document.getElementById(); // получить объект по Id;

    const name = document.getElementsByTagName('Название тега'); // получить псевдомассив объектов по тегу объекта;
    const name = document.getElementsByTagName('Название тега')[x]; // получить определённый объект с номером x из псевдомассива;

    const name = document.getElementsByClassName('Название класса'); // получить псевдомассив объектов по названию класса;

## Более современные методы.

    const names = document.querySelectorAll('Название селектора'); // получить псевдомассив объектов по CSS селектору;

    const name = document.querySelector('Название селектора'); // получить первого объекта по CSS селектору;


# Действия с элементами на странице.

    name.style.названиеСтиля = 'something'; // изменить CSS стиль у объекта;

    const tag = document.createElement('tag'); // создать элемент HTML-разметки, где tag - название тега, который нужно создать;

    tag.classList.add('class'); // добавить к элементу класс;

    document.body.append(tag); // добавить элемент tag в конец body;
    названиеТега.append(tag); // добавить элемент tag в конец тега;

    названиеТега.prepend(tag); // добавить элемент tag в конец начало;

    названиеТега1.before(tag); // добавить tag до тега1;
    названиеТега1.after(tag); // добавить tag после тега1;

    name.remove(); // удалить элемент;

    какойЭлементЗаменить.replaceWith(какимЭлементомЗаменить); // замена;

    name.innerHTML = 'someText'; // вписать текст с использованием HTML-тегов;

    name.textContent = 'someText'; // работает только с текстом БЕЗ использования HTML-тегов;

    name.insertAdjacentHTML('beforebegin', 'HTMLКоторыйМыХотимВставить'); // позволяет вставить HTML перед элементом; ???
    name.insertAdjacentHTML('afterbegin', 'HTMLКоторыйМыХотимВставить'); // позволяет вставить HTML в начало перед элементом; ???
    name.insertAdjacentHTML('beforeend', 'HTMLКоторыйМыХотимВставить'); // позволяет вставить HTML перед концом;
    name.insertAdjacentHTML('afterend', 'HTMLКоторыйМыХотимВставить'); // позволяет вставить HTML после элемента;

Можно использовать следующую конструкцию. Она выберет все элементы с определенными тегами внутри блока класса.

     const name = document.querySelectorAll('.НазваниеКласса тегиВнутриКласса');


# События и их обработчики.


## Справочник по событиям:
**[Узнать подробнее](https://developer.mozilla.org/ru/docs/Web/Events)**

    const obj = document.querySelector('tag'); // получаем объект с сайта;

    obj.addEventListener('названиеСобытия', функцияКотораяБудетРаботатьПослеСобытия); // подключить обработчик событий

Некоторые события:

'click' - нажатие
'mouseenter' - навести мышкой
'submit' - отправка формы на сервер
'input' - событие ввода данных в форму
'change' - тоже что и input, но срабатывает, когда элемент перестаёт быть активным


    obj.addEventListener('названиеСобытия', event =>{
            Something...
    }); 

**event** - объект события, который описывает что произошло с объектом.

**event.target** - получить элемент, в котором произошло событие. К этому элементу можно применять все те же методы, описанные выше, например, .remove();

Для того, чтобы иметь возможность удалить функцию-обработчик событий, нужно вынести её отдельно.

    const someFunction = (arg) => {...};
    obj.addEventListener('названиеСобытия', someFunction);

После того, как выполнится какое-либо событие по элементу obj, скажем, 'click', начнёт выполняться функция someFunction.

    obj.removeEventListener('названиеСобытия', someFunction);

После назначения обработчика событий, мы его удаляем.

**Всплытие событий** - явление, при котором обработчик событий срабатывает сначала на самом вложенном событии, а потом по иерархии поднимается наверх.

Для того, чтобы отменить стандартное поведение браузера, используется следующая конструкция:

    const value = document.querySelector("Some");
    value.addEventListener('названиеСобытия', event =>{
    
        event.preventDefault(); // тот самый метод, который отменяет стандартное поведение;
        /* Какие-то действия... */
        
    });

Метод, отменяющий стандартное поведение, помещается в самое начало.

Для того, чтобы назначить обработчик событий на много объектов, используется следующая конструкция:

    const value = document.querySelectorAll('selector');
    value.forEach(item =>{
    
    item.addEventListener('названиеСобытия', someFunction);
    
    });
    
То есть, мы получаем список из всех объектов, а потом перебирает их через цикл и к каждому применяем обработчик событий.

В addEventListener можно передавать третий аргумент, который означает опции.
Например,
{once: true} - выполняет функцию один раз.

# Навигация по DOM элементам.

    document.body; // обратиться к тегу body;
    document.head; // обратиться к тегу head;
    document.documentElement; // обратиться к тегу html;
    
    document.tag.childNodes; // получить псевдомассив всех узлов, относящихся к tag;
    
    document.tag.firstChild; // получить узел первого ребенёка;
    document.tag.firstElementChild; // получить элемент первого ребенёка;
    
    document.tag.lastChild; // получить узел последнего ребёнка;
    document.tag.lastElementChild; // получить элемент последнего ребёнка;
    
    document.qurySelector('tag').parentNode; // получить узел родителя;
    document.qurySelector('tag').parentElement; // получить элемент родителя;
    
    document.qurySelector('[attrubute = "data"]'); // получить абрибут HTML;
    
    document.qurySelector('tag').nextSibling; // получить следующий узел;
    document.qurySelector('tag').previousSibling; // получить предыдущий узел;
    
    document.qurySelector('tag').nextElementSibling; // получить следующий элемент;
    document.qurySelector('tag').previousElementSibling; // получить предыдущий элемент;
    
Нужно заметить то, что нельзя путать элементы и узлы. 
    
**document.tag.childNodes;** получает псевдомассив из *узлов*, встроенного функционала, позволяющего получить элементы в JavaScript нет. 

Для того, чтобы реализовать этот функционал, используется следующий конструкция:

    for (let node of document.tag.childNodes){
        /* Избавляемся от текстовых узлов: */
        if (node.nodeName === "#text"){ continue; }
        /* Какие-то действия... */
    }

# События на мобильных устройствах.

touchstart - событие, которе возникает при касании к элементу.
touchmove - событие, которое возникает при движении пальцем по элементу.
touchend - событие, которое возникает при убирании пальца с элемента.
touchenter - событие, которое возникает, если палец во время скольжения по экрану, зашёл на элемент.
touchleave - событие, которое возникает, если палец во время скольжения по экрану, покинул элемент.
touchcancel - точка соприкосновения больше не регистрируется на поверхности.

## Примеры кода.

    // Добавляем глобальный обработчик событий, чтобы мы точно знали, что все DOM-узлы успели прогрузиться
    
    window.addEventListener('DOMContentLoaded', ()=>{ 
    
    const tag = document.querySelector('name'); // получаем элемент со страницы
        tag.addEventListener('ОдноИзСобытийОписанныхВыше', (event) => { // добавляем обработчик событий
            event.preventDefault(); // желательно отменять стандартное поведение браузера
            /* Какой-то код... */
        });
    });
    
Объект event обладает следующими свойствами:

    event.touches; // возвращает список всех пальцев на экране с информацией. 
    
    event.targetTouches; // возвращает список всех пальцев на определенном элементе с информацией.
    
    event.changedTouches; // количество пальцев, участвующих в данном событии.

# Async, defer, динамические скрипты.

## defer.

Атрибут **defer** позволяет браузеру загружать страницу и при этом, загружать скрипт в фоновом режиме. А потом браузер запустит этот скрипт, когда он загрузится. Скрипты с таким атрибутом выполняются уже тогда, когда наше DOM дерево уже готово.

Эти атрибуты загружаются последовательно:
    
    <script defer scr="script1.js"></script>
    <script defer scr="script2.js"></script>

Сначала загрузится **script1.js**, а после него уже **script2.js**.

## async.

Страница не ждёт асинхронных скриптов. Содержимое просто обрабатывается и отображается. Загружается в фоновом режиме и запускается, как только он загрузился. Он никого не ждёт.

## Помещение скриптов на страницу.

Добавить скрипт на страницу можно при помощи следующей конструкции:

    const script = document.createElement('script'); // создаём DOM-элемент с тегом <script>
    script.src = "ПУТЬ К СКРИПТУ";// добавляет атрибут, с путём к файлу .js, который нужно подключить к странице;
    document.body.append(script); // помещает наш скрипт в конец <body>;
    
Данные скрипты ведут себя по умолчанию, как **async**.

Можно отключить данное поведение:
    
    script.async = false;

# ClassList и делегирование событий.

    obj.classList; // получить псевдомассив классов;
    ojb.classList[i].lenght; // получить количество классов;
    obj.classList.item(i)); // получить класс под индексов i;
    
    obj.classList.add('className'); // добавить класс;
    obj.classList.remove('className'); // удалить класс;
    obj.classList.toggle('className'); // если этот класс есть на элементе, то он будет добавлен, если его нет, то удалён.
    
Можно проверить наличие класса при помощи следующей конструкции:

    if(obj[i].classList.contains('className'){ /*...*/ }
    
## Делегирование.
    
Можно повесить обработчик событий на весь блок:

    wrapper.addEventListener('НазваниеСобытия',(event) =>{
    
       if (event.target && event.target.tagName === "НАЗВАНИЕ_ЭЛЕМЕНТА"){
          /* Какие-то действия... */
       }
    
    });
    
То есть, код вверху проверяет соответствие элемента его названию. Название можно получить при помощи команды:

    console.dir(event.target.tagName); 

# Табы.

Табы - это переключение между элементами.

Реализуем для начала две функции.

Первая функция будет скрывать контент.


# Вызов функции через некоторое время.
    
Код, описанный ниже выводит в консоль данные arg.

Сначала создаётся переменная value, потом ей присваивается значение функции setTimeout, внутри которой 
первым аргументов мы подаём функцию, которую нужно вызвать через время time, которое подаётся вторым аргументов,
после этого подаются все остальные аргументы, которые будет использовать функция, переданная первым аргументом.

    const value = setTimeout(function (arg){
        console.log(arg);
    }, time, arg);

Функция может работать и без определения переменной.

    setTimeout(function, time, arg);
    
Задание переменной используется для отслеживания функций.

Чтобы остановить исполнение кода, используется следующий код:

    clearInterval(timeFunction);
   
Чтобы задать временной интервал:

        const timerId = setInterval(()=>{
            /* Какой-то функционал, который будет
            выполнять каждые n * 1000 секунд
            */
        },n);

Рекурсивный timeOut:

    /* сначала создаём функцию id, потом в ней ещё одну функцию func,
    потом в конце этой функции перезаписываем id на setTimeout, в котором
    уже вызываем функцию func */
    
    let id = setTimeout(function func(){ 
        /* Какой-то код */
        id = setTimeout(func, время);
    }, время);
    
Преимущество этого метода в том, что он будет ждать конца каждого выполнения функции.

# Работа с датами.

    const value = new Date(); // создать дату с текущей датой и временем;
    
    const now = new Date('YYYY-MM-DD'); // создать произвольную дату
    
Всё время в объекте Date хранится в миллисекундах.

[Документация.](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date)


        /* Здесь мы просто скрываем содержимое таба */
        function hideTabContent() {
         tabsContent.forEach(item =>{
            item.style.display = 'none';    
         });
         
        /* Здесь мы перебираем все элементы внутри табов и удаляем класс, который 
        указывает на их активность. То есть, он указывает на то, какой контент может
        находиться на странице при его активном нажатии, либо сам таб может выглядеть иначе */
        
        
         tabs.forEach(item =>{
             item.classList.remove('tabheader__item_active'); 
         });
         }
         
Вторая функция наоборот будет переключать нас на активный элемент таба.
     
     /* i - определяет номер таба, которые нужно показывать */
     function showTabContent(i = 0) {
     
            tabsContent[i].style.display = 'block';
            /* Вот здесь мы добавляем класс активности, который удалили ниже */
            tabs[i].classList.add('tabheader__item_active');
     }

Потом вызываем эти функции.

    hideTabContent();
    showTabContent();

При помощи следующего кода реализован сам механизм переключения.
   
    /* Добавляем к родителю, то есть к блоку, где находятся эти табы 
    обработчик событий, который срабатывает только при возникновении
     какого-либо события*/
    
    tabsParent.addEventListener('названиеСобытия', (event) =>{
        const target = event.target,
            contains = target.classList.contains('tabheader__item');
            
            /* Если элемент с таким классом содрежится, то выполняется код внутри if */
            
        if (target && contains) {

           tabs.forEach((item, index) =>{

               /* target возвращает элемент, на который в данный момент мы нажали.
               * потом при помощи функции forEach, мы перебираем весь массив, при этом,
               * в index запоминается номер элемента. И если они совпали, то
               * скрывается весь предыдущий контент и вызывается функция, которая
               * показывает элемент по индексу.
               * */

               if (target === item){
                   hideTabContent();
                   showTabContent(index);
               }
           });
        }
    });

# Параметры документа, окна и работа с ними

    const element = document.querySelector('selector'); // получаем объект;
    
    element.clientWidth; // получить ширину элемента;
    element.clientHeight; // получить высоту элемента;
    
    element.offsetWidth; // тоже получить ширину элемента(другой способ), смотреть изображение ниже;    
    element.offsetHeight; // тоже получить высоту элемента(другой способ), смотреть изображение ниже;
    
    element.scrollTop; // показывает сколько пикселей неотлистанного контента нам не показывается;
    
Элементы показаны на картинке:
![Картинка](https://i.imgur.com/NbqUlkc.png)

Можно получить все координаты элементы:

    element.getBoundingClientRect(); // возвращает объект с координатами;
   
Можно получить все стили объекта:

    window.getComputedStyle(element); // возвращает объект со стилями;

Чтобы узнать высоту всего документа, используется следующее:

    document.documentElement.clientWidht; // высота;
    
Подобным образом можно узнать и другие характеристики документа.

Можно пролистать страницу следующим образом:

    widnow.scrollBy(x,y); // относительно текущей позиции;
    widnow.scrollTo(x,y); // относительно всей страницы;

Пример кода, при котором что-то будет выполняться, при условии, что пользователь пролистал до конца страницы.

    window.addEventListener('scroll', ()=>{

        if (window.pageYOffset + document.documentElement.clientHeight >=
         document.documentElement.scrollHeight){
            /* code */
        }

    });

# Поддержка клавиш на клавиатуре.

На [этом](https://keycode.info/) сайте можно найти коды всех клавиш клавиатуры.

Чтобы добавить обработчик событий, используется следующая конструкция.

    document.addEventListener('keydown',(event)=>{ // добавляем к документу обработчик событий с событие 'keydown'

        if (event.code === "НомерКлавиши"){  // проверка на соотвествие
            /* code... */
            }

        }); // последний аргумент указывает на то, что это событие будет перехвачено только один раз
        
         
    
# Функции-конструкторы.

Создать функцию конструктор можно следующим образом:

    function funcName(arg1, arg2){
        this.arg1 = arg1; // создаём поля;
        this.arg2 = arg2;
        this.arg3 = x; // создаём ещё одно поле объекта с определённым свойством, характерным для всех объектов;
        this.method = function (){ // можно создавать методы;
            /* code... */ 
            }
        }
    }

Создаётся объект следующим образом:

    const obj = new funcName(x,y); // получим объект;
    const obj2 = new funcName(z,t); // ещё один объект с теми же свойствами, но другими значениями;
    
Можно добавлять свойства уже к созданным объектам:

    obj.prototype.названиеМетода = function (){/* code... */}; // добавить метод;
    obj.prototype.названиеПоля = value; // добавить поле;
    
# This.

1. Обычная функция: **this** = window, если стоит *'use strict'*, то будет **undefined**;
2. Контекст у методов объекта - сам объект.
3. **this** в конструкторах и классах - новый экземпляр объекта.
4. Ручная привязка **this** при помощи **call**, **apply**, **bind**.

#AJAX.

    const request = new XMLHttpRequest(); // получить request метод;
    request.open(method, URL); // method - метод получения GET или POST, URL - путь файла начиная от index.html;
    request.setRequestHeader('Content-type', 'application/json; charset=utf-8'); // указать, что мы используем. В данном случае json файл.
    request.send(); // отправить запрос на сервер;
    
## Свойства:

**status** - статус HTTP запроса.

**statusText** - текст статуса HTTP запроса.

**response** - ответ от сервера.

**readyState** - текущее состояние HTTP запроса.

Полный код:
    
    // Сначала мы получаем input с сайта.
    const inputRub = document.querySelector('#rub'),
          inputUsd = document.querySelector('#usd');
    
    // Вешаем на него обработчик событий.
    inputRub.addEventListener('input', ()=>{ 
        
        // Уолучаем объект реквеста;
        const request = new XMLHttpRequest();
        
        // Устанавливаем настройки того, что мы будем читать;
        request.open('GET',  'current.json');
        request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
        
        // Отправляем его на сервер;
        request.send();
        
        // Добавляем обработчик событий, который сработает после отправки запроса на сервер;
        request.addEventListener('load',()=>{
        
            // Условие, которое проверят успешность;
            if (request.status === 200){
                
               // Получаем объект типа JSON из нашего файла
               const data = JSON.parse(request.response);
               
               // Рассчитываем значение и записываем его во вторую графу
               inputUsd.value = +inputRub.value / data.current.usd;
            }
        });
    });
    
    
 # Promise.
 
    /* Создаем переменную с объектом Promise, внутрь мы помещаем функцию,
    которая содержит два аргумента:
    resolve и reject. 
    Они являются функциями.
    */
    
    const req = new Promise(function(resolve, reject){
    /* Уже внутри объекта Promise мы эмулируем работу сервера */
    
    setTimeout(()=>{
    
    console.log('Request data');
    
        const backendData = {
            server: 'aws',
            port: 4000,
            status: "loading",
            }
            
            // resolve() будет вызвана только в случае успеха;
            
            resolve(backendData); // мы передаём backendData, чтобы потом использовать её в .then();
            
        }, 2000);
    });
     
    // этот код будет вызван, когда будет закончена некоторая асинхронная операция;
    req.then((data) => { // data мы получили, потому что поместили этот объект в функцию resolve();
        return = new Promise((resolve, reject)=>{ // Возвращаем объект с кодом ниже;
       
                setTimeout(() => {
                    data.modefied = true;   // модифицируем этот объект;
                    resolve(data);          // возвращаем модифицировый объект;
                }, 2000);
        }); 
        
    }).then( modData =>{ // вот здесь мы обращаемся к объекту, который вернулив выше.
    
    console.log(modData); // выводим уже модифицированный объект в консоль.
    
    }); 

**.catch** - будем попадать сюда, в случае ошибки;

**throw** - вызвать ошибку;

**.finally** - будет вызван в любой случае;

**Promise.all(массив)** - получает массив из Promise и возвращает Promise. Возвращенный Promise будет выполнен только тога, когда завершатся все Promise в массиве;

    // пример функции задержки;
    
    const sleep = (ms) =>{
        return new Promise(resolve => {
            setTimeout(()=>{
                return resolve();
            }, ms);
        });
    }
    
Данный код внутри then будет выполнен только после того, как отработают обе функции:

    Promise.all([sleep(1000), sleep(2000)]).then(()=>{
        console.log('OK');
    });
    
**Promise.race(массив)** - получает массив из Promise и возвращает Promise. Возвращенный Promise будет выполнен только тога, когда выполнился самый быстрый Promise в массиве;

    Promise.race([sleep(1000), sleep(2000)]).then(()=>{
        console.log('OK');
    });
    
#Fetch API.

**API** - Application Programing Interface 

**fetch** создаётся следующем образом:

    fetch('https://jsonplaceholder.typicode.com/todos/1') // если сюда не передавать никаких параметров, то будет обычный GET запрос;
        .then(response => response.json()) // при помощи .json превращаем данные в объект JavaScript;
        .then(json => console.log(json));
        
Для того, чтобы отправить POST запрос, используется следующий код:


    const init = { // создаём объект настроек
          // Метод отправки;
          method: "POST", // *GET, POST, PUT, DELETE, etc.
          
          // тело, которое мы будем отправлять на сервер;
          body: JSON.stringify({name: 'Alex'}), 
          
          // Заголовки, указыаем тип отправляемого объекта.
          headers: {  
          'Content-Type': 'application/json'  
          }
          
    // Сюда вставляем ссылку, куда мы будем отправлять и файл настроек.
    fetch('https://jsonplaceholder.typicode.com/posts', init) 
        .then(response => response.json())
        .then(json => console.log(json));
        
        
# Методы перебора массивов.

**filter**

    // Есть массив arr;
    arr.filter(value=>{
    
    // Здесь условие, которому должны соотвествовать элементы
    return value.lenght < 5; // Вернёт все элементы, длина строк которых меньше 5;
    
    });


**map**

    // Есть массив arr;
    arr.map(value=>{
    
    // Здесь мы указываем, что делать с каждым элементом;
    return value.toLowerCase; // Вернёт все элементы, но уже с нижним регистром.
    
    });

Нужно заметить то, что **filter** и **map** никак не изменяет исходный массив, а лишь возвращает новый массив.


**every/some**

    // Есть массив arr;
    arr.some(value=>{
    
    // Здесь мы указываем, что нужно проверить;
    return typeof(value) === 'number'; // проверить есть ли в массиве число;
    
    // Метод возвращает boolean тип;
    
    });
    
    
    // Есть массив arr;
    arr.every(value=>{
    
    // Здесь мы указываем, что нужно проверить для ВСЕХ элементов;
    return typeof(value) === 'number'; // проверить ВСЕ ли элементы в массиве числа;
    
    // Метод возвращает boolean тип;
    
    });
    
    
**reduce**

При помощи этого метода можно реализовать сложение следующим образом:


    const arr5 = [4, 5, 1, 4, 43, 6];
    /*           Изначально sum = 4, что соотвествует нулевому элементу = 4          
     *           Потом к sum прибавляется первый элемент
     *           sum = 9 потом к ней прибавляется следующий элемент = 1
     *           sum = 9 + 1 потом к ней прибавляется следующий элемент 4
     *           ...                                          
     *                                                                  
     *                                                                         */
    const result = arr.reduce((sum, current)=> sum + current, здесьМожноПередатьНачальноеЗначение); // таким образом мы получили сумму всех элементов в массиве;
    
Объект можно превратить в матрицу:

    Object.entries(obj); // где obj, объект, который нужно превратитьв матрицу.
    Object.fromEntries(matrix); // где matrix, матрица, которую нужно превратить в объект.
    
# localStorage

Этот объект используется для сохранения каких-либо данных или настроек пользователя на сайте.
То есть человек может зайти на сайт, что-то поменять там, а потом выйти и конкретно для него эти данные сохранятся. Этот объект существует только внутри одного домена.

    localStorage.setItem('key', value); // установить ключ и значение;
    
    localStorage.getItem('key'); // получить значение по название ключа;
    
    localStorage.removeItem('value'); // удалить по названию ключа;
    
    localStorage.clear(); // очистить полностью хранилище;
    

Чтобы передать в хранилище объект, его нужно предварительно превратить в строку.

    const value = JSON.stringify(obj);
    localStorage.setItem(key, value);

# Регулярные выражения.

Любое регулярное выражение состоит из двух частей: pattern и flags. 

pattern - шаблон того, что мы ищем в строке.

    const reg = /pattern/; // создать шаблон
    
Можно искать совпадения в строках:

    const str = 'hello'
    const reg = /h/i;
    
    // вернёт индекс символа, который совпал с шаблоном, если совпадений нет, то вернёт -1;
    str.search(reg); 
 
Флаги:

**i** - если хотим что-то найти, не зависимо от регистра;
**g** - найти сразу несколько вхождений
**m** - многострочный режим
    
    const reg = /pattern/g
    str.match(reg); // вернёт массив из всех совпадений;

    
    str.repace(чтоМыЗаменяем, наЧтоМыЗаменяем); // заменить
    
Свойства регулярных выражений:

**/./g** - берёт абсолютно все элементы из строки

**/\./** - при помощи **\** происходит экранирование


    // в reg содержится регулярное выражение, в ans содержится сама строка. Вернёт true, если есть совпадения, если их нет - false;
    reg.test(ans); 
    
Классы.

**\d** - цифры

**\w** - буквы

**\s** - пробелы

Обратные классы.

**\D** - НЕ цифры

**\W** - НЕ буквы    

**\S** - НЕ пробелы

    
# Геттеры и сеттеры.

    get name (){
        return this.value;
        }
    
    set name (input){
        this.value = input;
    }
    